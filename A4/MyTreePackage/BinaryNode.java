// CS 0445 Spring 2018// BinaryNode class for Assignment 4.  Add the methods specified in the// assignment sheet so that this class works correctly.  I have included// them with empty bodies below.package MyTreePackage;import javax.swing.*;import java.awt.*;import java.awt.event.*;/**   A class that represents nodes in a binary tree.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class BinaryNode<T>{  private T             data;  private BinaryNode<T> leftChild;  // Reference to left child  private BinaryNode<T> rightChild; // Reference to right child  public BinaryNode()  {     this(null); // Call next constructor  } // end default constructor  public BinaryNode(T dataPortion)  {      this(dataPortion, null, null); // Call next constructor  } // end constructor  public BinaryNode(T dataPortion, BinaryNode<T> newLeftChild,                                    BinaryNode<T> newRightChild)  {     data = dataPortion;     leftChild = newLeftChild;     rightChild = newRightChild;  } // end constructor  /** Retrieves the data portion of this node.      @return  The object in the data portion of the node. */  public T getData()  {     return data;  } // end getData  /**       Sets the data portion of this node.      @param newData  The data object.  */  public void setData(T newData)  {    data = newData;  } // end setData  /**     Retrieves the left child of this node.    @return  The node’s left child.   */  public BinaryNode<T> getLeftChild()  {    return leftChild;  } // end getLeftChild  /**     Sets this node’s left child to a given node.    @param newLeftChild  A node that will be the left child. */  public void setLeftChild(BinaryNode<T> newLeftChild)  {    leftChild = newLeftChild;  } // end setLeftChild  /**     Detects whether this node has a left child.    @return  True if the node has a left child. */  public boolean hasLeftChild()  {    return leftChild != null;  } // end hasLeftChild  /**     Retrieves the right child of this node.    @return  The node’s right child. */  public BinaryNode<T> getRightChild()  {    return rightChild;  } // end getRightChild     /**     Sets this node’s right child to a given node.    @param newRightChild  A node that will be the right child. */  public void setRightChild(BinaryNode<T> newRightChild)  {    rightChild = newRightChild;  } // end setRightChild     /**    Detects whether this node has a right child.    @return  True if the node has a right child. */  public boolean hasRightChild()  {    return rightChild != null;  } // end hasRightChild     /**     Detects whether this node is a leaf.    @return  True if the node is a leaf. */  public boolean isLeaf()  {   return (leftChild == null) && (rightChild == null);  } // end isLeaf  /**     Counts the nodes in the subtree rooted at this node.    @return  The number of nodes in the subtree rooted at this node.   */  public int getNumberOfNodes()  {    int leftNumber = 0;    int rightNumber = 0;          if (leftChild != null)      leftNumber = leftChild.getNumberOfNodes();          if (rightChild != null)      rightNumber = rightChild.getNumberOfNodes();          return 1 + leftNumber + rightNumber;  } // end getNumberOfNodes     /**     Computes the height of the subtree rooted at this node.    @return  The height of the subtree rooted at this node. */  public int getHeight()  {    return getHeight(this); // Call private getHeight  } // end getHeight  private int getHeight(BinaryNode<T> node)  {    int height = 0;    if (node != null)     height = 1 + Math.max(getHeight(node.getLeftChild()), getHeight(node.getRightChild()));                                 return height;  } // end getHeight  /**     Copies the subtree rooted at this node.    @return  The root of a copy of the subtree rooted at this node.   */  public BinaryNode<T> copy()  {    BinaryNode<T> newRoot = new BinaryNode<>(data);          if (leftChild != null)      newRoot.setLeftChild(leftChild.copy());          if (rightChild != null)      newRoot.setRightChild(rightChild.copy());          return newRoot;  } // end copy     // **********************************	// Complete the additional methods below	// **********************************	  /**    Checks if the tree is full or not full.    @return True if full, otherwise returns false.  */  public boolean isFull()  {    return isFull(this, getHeight(), 1);  }	private boolean isFull(BinaryNode<T> node, int height, int level)		{      // leaf or single node    if(node.leftChild == null && node.rightChild == null && data != null && height == level)      return true;    else if (node.leftChild != null && node.rightChild != null) //else possibly full tree      return isFull(node.getLeftChild(), height, level+1) &&             isFull(node.getRightChild(), height, level+1);    else  // else either L or R child is null or empty tree      return false;	}	/**    Tells if the tree is balanced (i.e. the difference in height between the left & right         subtrees is at most k)    @return Returns true if 1) the difference in height between the left and right subtrees    is at most k, and  2) the left and right subtrees are both recursively k-balanced.    Returns false otherwise  */  public boolean isBalanced(int k)	{	      if(data!=null)        return isBalanced(k, this);      else        return false;	}  private boolean isBalanced(int k, BinaryNode<T> node)  {    if (node != null)    {      return k >= Math.abs(getHeight(node.getLeftChild()) - getHeight(node.getRightChild()))                        && isBalanced(k, node.getLeftChild())                         && isBalanced(k, node.getRightChild());    }    else      return true;   }  // ************************************  // Assignment 4 Extra Credit Start Here  // ************************************  public  void drawTree()  {    drawTree(null); //Calls next method if no string argument passed in  }  public  void drawTree(String s)   {    int height = this.getHeight();    int width = (int)Math.pow(2.0, height - 1);    DrawTree<T> dt;    if (data instanceof String)      dt = new DrawTree<T>(this, height, width*90, height*100 , s);    else      dt = new DrawTree<T>(this, height, width*50, height*100, s);    dt.draw();  }  private class DrawTree<T> extends JPanel   {      private int treeHeight; //height of the binary tree      private BinaryNode<T> root; //root node of the tree      private Font font = new Font("Arial", Font.BOLD, 20);            /**         Default constructor that creates a window that displays the contents of the Binary         Tree.         @param node A BinaryNode (root of a tree)         @param tHight Calculated height of the tree         @param width Window width         @param height Window height         @param s Used to customize the window title (optional)       */      public DrawTree (BinaryNode<T> node, int tHeight, int width, int height, String s)       {        root = node;        treeHeight = tHeight;        setBackground(Color.white);        setForeground(Color.black);        JFrame jf = new JFrame("BT Structure" + (s!=null?": "+s:""));        //Exits on close        jf.addWindowListener(new WindowAdapter()           { public void windowClosing(WindowEvent e){ System.exit(0);}});                jf.getContentPane().add(this, BorderLayout.CENTER);        jf.setSize(new Dimension(width, height));        jf.setVisible(true);      }      /**          Initiates the drawing       */      public void draw()       {          paintImmediately(0,0, getWidth(), getHeight());      }      /**        Method is called when window needs to be repainted.        @param g Graphics object for drawing.      */      protected void paintComponent(Graphics g)       {          super.paintComponent(g);          //getHeight() is of the panel, not the tree          drawRec(g, 0, getWidth(), 0, getHeight()/ treeHeight, root);      }       /**        Recursive method for drawing the tree.        @param g Graphics object for drawing.        @param xMin Minimum x value        @param xMax Maximum x value         @param y Starting y value        @param ySpace Spacing between lines        @param node Binary node which will be drawn      */      protected void drawRec(Graphics g, int xMin, int xMax, int y, int ySpace,         BinaryNode<T> node)       {          String s = node.getData().toString();          g.setFont(font);          FontMetrics fm = g.getFontMetrics();          int width = fm.stringWidth(s); //Width of the data from the node          int height = fm.getHeight();    //Height of the data from the node          int xSpace = Math.min((xMax - xMin)/8, 20);          g.drawString(s, (xMin + xMax)/2 - width/2, y + ySpace/2);          //Draws a line from the parent to the child, then recursively draws the child          if (node.hasLeftChild())           {              //Connects parent node with child node              g.drawLine((xMin + xMax)/2 - xSpace, y + ySpace/2 + 5,                          (xMin + (xMin + xMax)/2) / 2,                          y + ySpace + ySpace/2 - height);              drawRec(g, xMin, (xMin + xMax)/2, y + ySpace, ySpace, node.getLeftChild());          }          if (node.hasRightChild())           {              g.drawLine((xMin + xMax)/2 + xSpace, y + ySpace/2 + 5,                         (xMax + (xMin + xMax)/2) / 2,                          y + ySpace + ySpace/2 - height);              drawRec(g, (xMin + xMax)/2, xMax, y + ySpace, ySpace, node.getRightChild());          }      }  }} // end BinaryNode