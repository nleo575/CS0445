// CS 0445 Spring 2018// Assignment 4// Implementation for the additional operations in the ComparableBinaryTreepackage MyTreePackage;import java.util.*;import java.io.*;	// Needed for Assignment 4 methodsimport java.util.Iterator;import java.util.NoSuchElementException;import StackAndQueuePackage.*; // Needed by tree iteratorspublic class ComparableBinaryTree<T extends Comparable<? super T>> extends BinaryTree<T> 			implements ComparableTreeInterface<T>{	/**		Public constructor calls BinaryTree constructor	*/	public ComparableBinaryTree()	{	  super();	} // end default constructor	// If the tree is not empty, return the maximum	// value in the tree; otherwise return null	public T getMax()		{		if(!isEmpty())			return getMax(getRootNode());		else			return null;	}	private T getMax(BinaryNode<T> node)	{		T result = node.getData(); //Assume max is data of the node		T temp; 				   //Result of left &/or right children		if(node.hasLeftChild())		{				temp = getMax(node.getLeftChild());			result = result.compareTo(temp)<0? temp:result;		}		if(node.hasRightChild())		{				temp = getMax(node.getRightChild());			result = result.compareTo(temp)<0? temp:result;		}		return result;	}	// If the tree is not empty, return the minimum	// value in the tree; otherwise return null	public T getMin()		{		if(!isEmpty())			return getMin(getRootNode());		else			return null;	}	private T getMin(BinaryNode<T> node)	{		T result = node.getData(); //Assume min is data of the node		T temp; 				   //Result of left &/or right children		if(node.hasLeftChild())		{				temp = getMin(node.getLeftChild());			result = result.compareTo(temp)>0? temp:result;		}		if(node.hasRightChild())		{				temp = getMin(node.getRightChild());			result = result.compareTo(temp)>0? temp:result;		}		return result;	}	// Return true if the the tree meets the	// recursive definition of a BST; else	// return false	public boolean isBST()	{		return isBST(getRootNode());	}	private boolean isBST(BinaryNode<T> node)	{		if(node == null) //Empty tree is a BST (i.e. null pointer or end of leaf)			return true;		else		{			boolean result = true;			if (node.hasLeftChild()) 				result = node.getData().compareTo(getMax(node.getLeftChild())) >0;			if (node.hasRightChild()) 				result = result && node.getData().compareTo(getMax(node.getRightChild()))<0;			return result && isBST(node.getLeftChild()) && isBST(node.getRightChild());		}	}	/**		@return Returns the rank of data in the tree with 0 being the smallest answer and		N being the largest answer. Data does not have to be present in the tree.  		If duplicates are present in the tree this answer should be minimized.	*/	public int rank(T data)	{		return rank(data, getRootNode());	} 	 	private int rank(T data, BinaryNode<T> node) 	{		if(node == null) //Empty tree means rank is 0			return 0;		else		{			int result = node.getData().compareTo(data) < 0 ? 1 : 0;			if (node.hasLeftChild()) 				result += rank(data, node.getLeftChild());			if (node.hasRightChild()) 				result += rank(data, node.getRightChild());			return result;		} 	}	/**	 	Return the value in the tree with rank i in the ordering.  If there are duplicates		the first occurrence should be returned.			@return Return the value in the tree with rank equal to i. i should be in 		range 0 to N-1 (where the N is the number of nodes in the tree). If i is out of 		range, throws an IndexOutOfBoundsException.	*/			  	public T get(int i)	{		if (i < 0 || i > getNumberOfNodes() -1)			throw new IndexOutOfBoundsException();		else			return get(getRootNode(), i);	} 	private T get(BinaryNode<T> node, int i)	{			T temp = null;		if (rank(node.getData()) == i)			return node.getData();		if(node.hasLeftChild())			temp =  get(node.getLeftChild(), i);		if(node.hasRightChild() && temp == null)			temp =  get(node.getRightChild(), i);		return temp;	}}