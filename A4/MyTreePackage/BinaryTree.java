// CS 0445 Spring 2018// Modified BinaryTree class.  I have implemented one of the required methods// for you -- see (far) below.  You must complete the implementations for the // remaining methods.  You may NOT use any of the Iterator methods in the// implementations of your methods.package MyTreePackage;import java.util.*;import java.io.*;	// Needed for Assignment 4 methodsimport java.util.Iterator;import java.util.NoSuchElementException;import StackAndQueuePackage.*; // Needed by tree iterators/**   A class that implements the ADT binary tree.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class BinaryTree<T> implements BinaryTreeInterface<T>{   private BinaryNode<T> root;   public BinaryTree()   {      root = null;   } // end default constructor   public BinaryTree(T rootData)   {      root = new BinaryNode<>(rootData);   } // end constructor   public BinaryTree(T rootData, BinaryTree<T> leftTree,                                  BinaryTree<T> rightTree)   {      privateSetTree(rootData, leftTree, rightTree);   } // end constructor   public void setTree(T rootData)   {      root = new BinaryNode<>(rootData);   } // end setTree   public void setTree(T rootData, BinaryTreeInterface<T> leftTree,                                   BinaryTreeInterface<T> rightTree)   {      privateSetTree(rootData, (BinaryTree<T>)leftTree,                                (BinaryTree<T>)rightTree);   } // end setTree	private void privateSetTree(T rootData, BinaryTree<T> leftTree, 	                                        BinaryTree<T> rightTree)	{      root = new BinaryNode<>(rootData);      if ((leftTree != null) && !leftTree.isEmpty())         root.setLeftChild(leftTree.root);             if ((rightTree != null) && !rightTree.isEmpty())      {         if (rightTree != leftTree)            root.setRightChild(rightTree.root);         else            root.setRightChild(rightTree.root.copy());      } // end if      if ((leftTree != null) && (leftTree != this))         leftTree.clear();              if ((rightTree != null) && (rightTree != this))         rightTree.clear();	} // end privateSetTree	public T getRootData()	{		if (isEmpty())			throw new EmptyTreeException();		else         return root.getData();	} // end getRootData	public boolean isEmpty()	{      return root == null;	} // end isEmpty	public void clear()	{      root = null;	} // end clear	protected void setRootData(T rootData)	{      root.setData(rootData);	} // end setRootData		// CS 0445 Spring 2018 I changed this from protected to public	public void setRootNode(BinaryNode<T> rootNode)	{      root = rootNode;	} // end setRootNode	protected BinaryNode<T> getRootNode()	{      return root;	} // end getRootNode	public int getHeight()	{      return root.getHeight();	} // end getHeight	public int getNumberOfNodes()	{      return root.getNumberOfNodes();	} // end getNumberOfNodes	public Iterator<T> getPreorderIterator()	{		return new PreorderIterator();		} // end getPreorderIterator	public Iterator<T> getInorderIterator()	{		return new InorderIterator();		} // end getInorderIterator		public Iterator<T> getPostorderIterator()	{		return new PostorderIterator();		} // end getPostorderIterator	public Iterator<T> getLevelOrderIterator()	{		return new LevelOrderIterator();		} // end getLevelOrderIterator	private class PreorderIterator implements Iterator<T>	{		private StackInterface<BinaryNode<T>> nodeStack;				public PreorderIterator()		{			nodeStack = new LinkedStack<>();			if (root != null)				nodeStack.push(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeStack.isEmpty();		} // end hasNext				public T next()		{			BinaryNode<T> nextNode;						if (hasNext())			{				nextNode = nodeStack.pop();				BinaryNode<T> leftChild = nextNode.getLeftChild();				BinaryNode<T> rightChild = nextNode.getRightChild();								// Push into stack in reverse order of recursive calls				if (rightChild != null)					nodeStack.push(rightChild);									if (leftChild != null)					nodeStack.push(leftChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PreorderIterator   	public void iterativePreorderTraverse()   	{      StackInterface<BinaryNode<T>> nodeStack = new LinkedStack<>();      if (root != null)         nodeStack.push(root);      BinaryNode<T> nextNode;      while (!nodeStack.isEmpty())      {			nextNode = nodeStack.pop();			BinaryNode<T> leftChild = nextNode.getLeftChild();			BinaryNode<T> rightChild = nextNode.getRightChild();						// Push into stack in reverse order of recursive calls			if (rightChild != null)				nodeStack.push(rightChild);         			if (leftChild != null)				nodeStack.push(leftChild);                  System.out.print(nextNode.getData() + " ");      } // end while   	} // end iterativePreorderTraverse   	private class InorderIterator implements Iterator<T>	{      private StackInterface<BinaryNode<T>> nodeStack;      private BinaryNode<T> currentNode;      public InorderIterator()      {         nodeStack = new LinkedStack<>();         currentNode = root;      } // end default constructor      public boolean hasNext()       {         return !nodeStack.isEmpty() || (currentNode != null);      } // end hasNext      public T next()      {         BinaryNode<T> nextNode = null;         // Find leftmost node with no left child         while (currentNode != null)         {            nodeStack.push(currentNode);            currentNode = currentNode.getLeftChild();         } // end while         // Get leftmost node, then move to its right subtree         if (!nodeStack.isEmpty())         {            nextNode = nodeStack.pop();            assert nextNode != null; // Since nodeStack was not empty                                     // before the pop            currentNode = nextNode.getRightChild();         }         else            throw new NoSuchElementException();         return nextNode.getData();       } // end next      public void remove()      {         throw new UnsupportedOperationException();      } // end remove	} // end InorderIterator	public void iterativeInorderTraverse()	{	  StackInterface<BinaryNode<T>> nodeStack = new LinkedStack<>();	  BinaryNode<T> currentNode = root;	  	  while (!nodeStack.isEmpty() || (currentNode != null))	  {	     // Find leftmost node with no left child	     while (currentNode != null)	     {	        nodeStack.push(currentNode);	        currentNode = currentNode.getLeftChild();	     } // end while	     	     // Visit leftmost node, then traverse its right subtree	     if (!nodeStack.isEmpty())	     {	        BinaryNode<T> nextNode = nodeStack.pop();	        assert nextNode != null; // Since nodeStack was not empty	                                 // before the pop	        System.out.print(nextNode.getData() + " ");	        currentNode = nextNode.getRightChild();	     } // end if	  } // end while	} // end iterativeInorderTraverse   	private class PostorderIterator implements Iterator<T>	{		private StackInterface<BinaryNode<T>> nodeStack;		private BinaryNode<T> currentNode;				public PostorderIterator()		{			nodeStack = new LinkedStack<>();			currentNode = root;		} // end default constructor				public boolean hasNext()		{			return !nodeStack.isEmpty() || (currentNode != null);		} // end hasNext      public T next()      {         boolean foundNext = false;         BinaryNode<T> leftChild, rightChild, nextNode = null;                  // Find leftmost leaf         while (currentNode != null)         {            nodeStack.push(currentNode);            leftChild = currentNode.getLeftChild();            if (leftChild == null)               currentNode = currentNode.getRightChild();            else               currentNode = leftChild;         } // end while                  // Stack is not empty either because we just pushed a node, or         // it wasn't empty to begin with since hasNext() is true.         // But Iterator specifies an exception for next() in case         // hasNext() is false.                  if (!nodeStack.isEmpty())         {            nextNode = nodeStack.pop();            // nextNode != null since stack was not empty before pop                        BinaryNode<T> parent = null;            if (!nodeStack.isEmpty())            {               parent = nodeStack.peek();               if (nextNode == parent.getLeftChild())                  currentNode = parent.getRightChild();               else                  currentNode = null;            }            else               currentNode = null;         }         else         {            throw new NoSuchElementException();         } // end if                  return nextNode.getData();      } // end next		public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PostorderIterator		private class LevelOrderIterator implements Iterator<T>	{		private QueueInterface<BinaryNode<T>> nodeQueue;				public LevelOrderIterator()		{			nodeQueue = new LinkedQueue<>();			if (root != null)				nodeQueue.enqueue(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeQueue.isEmpty();		} // end hasNext				public T next()		{			BinaryNode<T> nextNode;						if (hasNext())			{				nextNode = nodeQueue.dequeue();				BinaryNode<T> leftChild = nextNode.getLeftChild();				BinaryNode<T> rightChild = nextNode.getRightChild();								// Add to queue in order of recursive calls				if (leftChild != null)					nodeQueue.enqueue(leftChild);				if (rightChild != null)					nodeQueue.enqueue(rightChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end LevelOrderIterator		// *******************************	// Assignment 4 Methods Start Here	// *******************************	// Return true if the current BT	// is a full tree and false otherwise.  See course notes for	// definition of a full tree.	public boolean isFull()	{		return root.isFull();	}	// Return true for the current	// BT if:	// 1) The difference in height of the left subtree and the right	// 		subtree is at most k and	// 2) Both the left subtree and the right subtree are (recursively)	//		k-balanced.	public boolean isBalanced(int k)	{		return root.isBalanced(k);	}		/** 		Builds a balanced BT from the file "fileName".  		@param filename Name of a properly formatted .dat file	*/	public void buildInorder(String filename)	{		try		{			ObjectInputStream IS = new ObjectInputStream(new FileInputStream(filename));					int n = IS.readInt(); //Number of nodes in the file			if (n > 0)			{				root = new BinaryNode<T>();				buildInorder(IS, n,root);			} 			else				root = null;		}		catch (IOException e)		{			System.out.println("Invalid filename. " + e);		}		catch (Exception e1)		{			System.out.println("File read error. " + e1);		}	}	private BinaryNode<T> buildInorder(ObjectInputStream IS, int n, BinaryNode<T> node)	{		try		{			if ((n/2)>0) 				node.setLeftChild(buildInorder(IS, n/2,new BinaryNode<T>()));			node.setData((T) IS.readObject());			if ((n - n/2 - 1) > 0)				node.setRightChild(buildInorder(IS, n - n/2 - 1, new BinaryNode<T>()));		}		catch (Exception e)		{			System.out.println("File recursive read error. " + e);		}		return node;	}	// I am giving you the code for this method so you can see how the recursion	// works and how you can utilize Object files. 	public void saveInorder(String fileName)	{		try		{			ObjectOutputStream OS = new ObjectOutputStream(				   new FileOutputStream(fileName));		// Create the object file			int n = getNumberOfNodes();			OS.writeInt(n);		// output the number of nodes				// Call the recursive method to output the nodes themselves			RecWriteTree(OS, (BinaryNode<T>)getRootNode());			OS.close();		}		catch (IOException e)		{			System.out.println("Writing problem");		}	}	public void RecWriteTree(ObjectOutputStream OS, BinaryNode<T> node)	{		if (node != null)	// Base case -- do nothing for empty node		{			try			{		// Recursively output left subtree				RecWriteTree(OS, (BinaryNode<T>) node.getLeftChild());					// output data in current node				OS.writeObject(node.getData());					// Recursively output right subtree				RecWriteTree(OS, (BinaryNode<T>) node.getRightChild());			}			catch (IOException e)			{				System.out.println("Rec Writing Problem" + e);			}		}	}	// ************************************	// Assignment 4 Extra Credit Start Here	// ************************************	/* 		Builds a complete BT from the file "fileName".  		Assume the first line of the file has 		an integer, N, indicating the number of values to follow.  The remaining N lines of 		the file contain N values.  The order of the values in the file should be preserved 		by the tree (i.e. an inorder traversal should show the data in the order stored in 		the file). Also if N = 2^K-1 for some K, the tree MUST be a FULL tree. If N != 2^K-1 		for some K, the tree should be optimally balanced but it does NOT have to be a 		complete tree. This method MUST build the tree recursively (hint: have it call a 		recursive method).  Use the readObject() method to read the objects (so the file  		can contain any type of Serializable objects).	*/	public void buildComplete(String filename)	{		try		{			ObjectInputStream IS = new ObjectInputStream(new FileInputStream(filename));					int n = IS.readInt(), //Number of nodes in the file				height = (int) Math.ceil(Math.log(n)/Math.log(2)), //Height of tree			    btmNodes =(int)Math.pow(2.0, height -1)-(int)Math.pow(2.0,height)+ 1 + n;				//[0] = # of leaves on the bottom row, necessary to make a complete tree		    BinaryNode<Integer> bNodes= new BinaryNode<Integer>(btmNodes);			if (n > 0) 			{				root = new BinaryNode<T>();				if (n>1) 					root.setLeftChild(buildComplete(IS, 2, height, bNodes));				root.setData((T) IS.readObject());				if (n > 2)					root.setRightChild(buildComplete(IS, 2, height, bNodes));			}			else				root = null;		}		catch (IOException e)		{			System.out.println("Invalid filename. " + e);		}		catch (Exception e1)		{			System.out.println("File read error. " + e1);		}	}	 BinaryNode<T> buildComplete(ObjectInputStream IS, int level, int height,		BinaryNode<Integer> bNodes)	{		BinaryNode<T> newNode = new BinaryNode<T> ();		try		{			if (level == height) 			{				newNode.setData((T) IS.readObject());				bNodes.setData(bNodes.getData() - 1);			}			else if (level < height - 1) 			{				newNode.setLeftChild(buildComplete(IS, level + 1, height, bNodes));				newNode.setData((T) IS.readObject());				newNode.setRightChild(buildComplete(IS, level + 1, height, bNodes));			}			else //Level == height -1			{				if(bNodes.getData() > 0)					newNode.setLeftChild(buildComplete(IS, level + 1, height, bNodes));								newNode.setData((T) IS.readObject());				if(bNodes.getData()  > 0)					newNode.setRightChild(buildComplete(IS, level + 1, height, bNodes));			}		}		catch (Exception e)		{			System.out.println("File recursive read error. " + e);		}		return newNode;	}	public void drawTree(String s) 	{	  root.drawTree(s); 	}} // end BinaryTree